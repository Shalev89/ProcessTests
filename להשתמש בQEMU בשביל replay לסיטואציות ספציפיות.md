קודם כל, קישור: [https://qemu.readthedocs.io/en/v9.2.0/system/replay.html]()
# סיכום כללי:
הפיצ'רים record replay של qemu מאפשרים לנו לשחזר שוב ושוב התנהגות, על ידי הקלטה של כל קלטים שאינם דטרמיניסטיים, ושל מצב התחלתי, ואז ניגון מחדש של הקלטים החיצוניים על שאר הקוד שלנו (כלומר - על החלקים הדטרמיניסטיים). לאחר ההקלטה, נוכל גם בעת כל הרצה להשתמש ב-gdb כדי לדבג את האירוע, וגם להשתמש אפילו בפיצ'ר בשם reverse debugging של gdb כדי כל פעם לחזור אחורה בהרצה. 
יש צורך להפעיל את qemu במצב icount למען שימוש בפיצ'ר, ולתת את הדגלים הרלוונטיים שיאמרו להקליט/לעשות replay.


יתרה מכך, אני חושב שאפשר להוסיף את פיצ'ר זה למען הרבה טסטים - כל טסט שניתן להריץ דרך QEMU, אז תמיד נריץ אותו עם הדגלים של ה-record, ואז, במידה והטסט נכשל, אז גם נשמור את הקובץ של ה-record, ואז לאדם שאחר כך הולך לבדוק למה הטסט נכשל - יהיה קובץ שמאפשר דיבוג מאוד נוח, שבו הוא יוכל ממש לבדוק לעקוב ולראות בדיוק מה היה המצב, ולשחזר את הכישלון שוב ושוב. זה אפילו ממש סופר קל, כי הוא יוכל פשוט לפתוח את ההרצה ב-gdb, לתת לה להגיע עד הסוף ולהיכשל, ואז לעשות פשוט reverse-stepi כדי ללכת אחורה בהרצה (אציין שאם לא נעשה שיישמרו snapshotים בכל interval קבוע, אז זה עלול להיות קצת איטי. אבל אני מניח שניתן גם בהרצות שאחרי הריצה הראשונית לשמור snaptshotים).

ייתכנו בעיות עם שחזור באגים בעזרת פיצ'ר זה, שכן אנו למעשה מפעילים virtual instruction counter, ולמעשה אנו שולטים (בין אם אנחנו נותנים לזה להיקבע אוטומטית או קובעים ממש בעצמנו) את כל כמה זמן ירוץ instruction. להלן החלק הרלוונטי מהתיעוד:
> Enable virtual instruction counter. The virtual cpu will execute one instruction every 2^N ns of virtual time. If auto is specified then the virtual cpu speed will be  automatically adjusted to keep virtual time within a few seconds of real time.
> 
> Note  that while this option can give deterministic behavior, it does not provide cycle accurate emulation. Modern CPUs contain superscalar out of order cores with complex cache hierarchies. The number of instructions executed often has little or no correlation with actual performance.

ולמרות שיש אופציה של לנסות לסנכרן בין ה-host clock לבין ה-virtual clock, זה לא הרמטי.
למעשה, החשש שלי הוא שעקב העובדה שאנו קובעים כל כמה זמן תרוץ פעולת מעבד, **אז אנו עלולים למנוע למעשה שחזורים של באגים שהם תלויים בתזמון**

# יומן המחקר עצמו (לפי סדר כרונולוגי):
ממה שמוסבר פה ([https://qemu.readthedocs.io/en/v9.2.0/system/replay.html]()), נראה שבגדול בגדול, השיטה היא לשמור ולעשות replay לאירועים שאינם דטרמיניסטיים, ולדמות אירועים דטרמיניסטיים. זה אומר שדברים כמו נגיד פקטות רשת נשמרים, אבל דברים כמו הזיכרון - לא נשמרים. 
בנוסף, אפשר לעשות snapshot של המצב הנוכחי, ואז להשתמש בו כדי לשחזר את המצב הזה. זה נגיד כן לשמור את ה-state הנוכחי לפי מה שאני מבין. למעשה זה כמו 'נקודת ההתחלה' של ה-replay. ניתן גם לשמור עוד snapshotים במהלך הריצה לפי הבנתי. 
יש גם אופציה של להקליט ולנגן מחדש (record and replay) להתנהגות רשתית - כלומר לפקטות. כאשר משתמשים בפילטר הקלטה של התנהגות רשתית, כל הפקטות המגיעות 'מהעולם החיצון' נשמרות ללוג, ואז בעת ה-replay הן 'מוזרקות' לרכיב הרשת. חשוב לציין - אי אפשר להתעסק עם ההתנהגות הרשתית ידנית בעת שעושים replay. 
פורטים סריאליים מוקלטים ומנוגנים מחדש אוטומטית ממה שאני מבין. 

בנוגע ל-reverse debugging (פיצ'ר של GDB) - זה טכנית נתמך, רק במקום שאנחנו באמת נחזור instruction/break point אחד אחורה כל פעם, ה-QEMU כל פעם ימצא את ה-snapshot הכי קרוב ומשם יעשה replay קדימה עד הנקודה הרצויה. **זה אומר שבעוד זה נתמך, זה כנראה יהיה מאוד איטי**

זה אולי לא כזה שימושי לנו כי זה נטו עובד על התנהגות שהיא בתוך QEMU, ולא עוזר לנו נגיד להקליט התנהגות של חומרה ואז לעשות לה replay. 

(למחוק אחר כך: צופה ב[https://www.youtube.com/watch?v=3g1KzfBl1kI]())

בגדול, בעזרת gdb נוכל לנתח בזמן הריצה את האירועים. נוכל גם למשל לעשות reverse debugging - שנחזור למעשה אחורה. (מצגת בנושא: [https://www.linux-kvm.org/images/d/d0/02x06b-DeterministicReplay.pdf]())

הדגמה של משהו דומה: https://www.youtube.com/watch?v=cICSFqpcr_4

כלי נוסף שאולי יכול להיות מעניין: https://rr-project.org/ (ממה שכתוב הוא גם תומך ב-qemu, אבל לא חקרתי אותו לעומק)

הגעתי למסקנה שעלולות להיות בעיות משמעותיות (כאלו שימנעו מפיצ'ר זה מלהיות שימושי) עקב העובדה שאנו מכתיבים ל-QEMU כל כמה זמן להריץ פעולת מעבד. בפרט, זה אומר שאנו לא מדמים את ההתנהגות בפועל של המעבד, אלא מדמים אותה במצב שבו אנו שולטים על קצב הריצה - דבר שעלול לפגוע קשות ביכולת שלנו לדמות/לתפוס בעיות סנכרון. מבחינתי, הייתי רוצה למצוא דרך שבה הריצה שאותה מקליטים תרוץ באופן 'רגיל' (קרי - שאנו לא שולטים במהירות של פקודות המעבד), ורק כשננגן את ההקלטה - זה יהיה נשלט. 
אם ניתן דגל של shift=auto, זה ינסה שהמהירות של המעבד הו
יכול להיות ששימוש בדגל align=on יעזור

למרות שיכול להיות שבאופן כללי qemu לא טוב בשביל דימוי בעיות שתלויות בסנכרון - כי זה לא רץ על החומרה המקורית.