קודם כל, קישור: [https://qemu.readthedocs.io/en/v9.2.0/system/replay.html]()
# סיכום כללי:
הפיצ'רים record replay של qemu מאפשרים לנו לשחזר שוב ושוב התנהגות, על ידי הקלטה של כל קלטים שאינם דטרמיניסטיים, ושל מצב התחלתי, ואז ניגון מחדש של הקלטים החיצוניים על שאר הקוד שלנו (כלומר - על החלקים הדטרמיניסטיים). לאחר ההקלטה, נוכל גם בעת כל הרצה להשתמש ב-gdb כדי לדבג את האירוע, וגם להשתמש אפילו בפיצ'ר בשם reverse debugging של gdb כדי כל פעם לחזור אחורה בהרצה. 
יש צורך להפעיל את qemu במצב icount למען שימוש בפיצ'ר, ולתת את הדגלים הרלוונטיים שיאמרו להקליט/לעשות replay.


יתרה מכך, אני חושב שאפשר להוסיף את פיצ'ר זה למען הרבה טסטים - כל טסט שניתן להריץ דרך QEMU, אז תמיד נריץ אותו עם הדגלים של ה-record, ואז, במידה והטסט נכשל, אז גם נשמור את הקובץ של ה-record, ואז לאדם שאחר כך הולך לבדוק למה הטסט נכשל - יהיה קובץ שמאפשר דיבוג מאוד נוח, שבו הוא יוכל ממש לבדוק לעקוב ולראות בדיוק מה היה המצב, ולשחזר את הכישלון שוב ושוב. זה אפילו ממש סופר קל, כי הוא יוכל פשוט לפתוח את ההרצה ב-gdb, לתת לה להגיע עד הסוף ולהיכשל, ואז לעשות פשוט reverse-stepi כדי ללכת אחורה בהרצה (אציין שאם לא נעשה שיישמרו snapshotים בכל interval קבוע, אז זה עלול להיות קצת איטי. אבל אני מניח שניתן גם בהרצות שאחרי הריצה הראשונית לשמור snaptshotים).

# יומן המחקר עצמו (לפי סדר כרונולוגי):
ממה שמוסבר פה ([https://qemu.readthedocs.io/en/v9.2.0/system/replay.html]()), נראה שבגדול בגדול, השיטה היא לשמור ולעשות replay לאירועים שאינם דטרמיניסטיים, ולדמות אירועים דטרמיניסטיים. זה אומר שדברים כמו נגיד פקטות רשת נשמרים, אבל דברים כמו הזיכרון - לא נשמרים. 
בנוסף, אפשר לעשות snapshot של המצב הנוכחי, ואז להשתמש בו כדי לשחזר את המצב הזה. זה נגיד כן לשמור את ה-state הנוכחי לפי מה שאני מבין. למעשה זה כמו 'נקודת ההתחלה' של ה-replay. ניתן גם לשמור עוד snapshotים במהלך הריצה לפי הבנתי. 
יש גם אופציה של להקליט ולנגן מחדש (record and replay) להתנהגות רשתית - כלומר לפקטות. כאשר משתמשים בפילטר הקלטה של התנהגות רשתית, כל הפקטות המגיעות 'מהעולם החיצון' נשמרות ללוג, ואז בעת ה-replay הן 'מוזרקות' לרכיב הרשת. חשוב לציין - אי אפשר להתעסק עם ההתנהגות הרשתית ידנית בעת שעושים replay. 
פורטים סריאליים מוקלטים ומנוגנים מחדש אוטומטית ממה שאני מבין. 

בנוגע ל-reverse debugging (פיצ'ר של GDB) - זה טכנית נתמך, רק במקום שאנחנו באמת נחזור instruction/break point אחד אחורה כל פעם, ה-QEMU כל פעם ימצא את ה-snapshot הכי קרוב ומשם יעשה replay קדימה עד הנקודה הרצויה. **זה אומר שבעוד זה נתמך, זה כנראה יהיה מאוד איטי**

זה אולי לא כזה שימושי לנו כי זה נטו עובד על התנהגות שהיא בתוך QEMU, ולא עוזר לנו נגיד להקליט התנהגות של חומרה ואז לעשות לה replay. 

(למחוק אחר כך: צופה ב[https://www.youtube.com/watch?v=3g1KzfBl1kI]())

בגדול, בעזרת gdb נוכל לנתח בזמן הריצה את האירועים. נוכל גם למשל לעשות reverse debugging - שנחזור למעשה אחורה. (מצגת בנושא: [https://www.linux-kvm.org/images/d/d0/02x06b-DeterministicReplay.pdf]())

הדגמה של משהו דומה: https://www.youtube.com/watch?v=cICSFqpcr_4

כלי נוסף שאולי יכול להיות מעניין: https://rr-project.org/ (ממה שכתוב הוא גם תומך ב-qemu, אבל לא חקרתי אותו לעומק)